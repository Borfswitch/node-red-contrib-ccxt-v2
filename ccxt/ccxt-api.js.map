{"version":3,"sources":["ccxt-api.js"],"names":["module.exports = function(RED) {\n","  \"use strict\";\n","  // load package dependencies\n","  var serveStatic = require(\"serve-static\");\n","  var path = require(\"path\");\n","  const ccxt = require(\"ccxt\");\n","  const exchanges = require(\"./js/exchanges\");\n","  //helper function needed for since arguments\n","  //returns milliseconds ephch time for a date\n","  // Date.prototype.getUnixTime = function() {\n","  //     return (this.getTime() / 1000) | 0;\n","  // };\n","  // Returns if value is a date object\n","  function isDate(value) {\n","    return value instanceof Date;\n","  }\n","  function sleep(ms) {\n","    return new Promise(resolve => setTimeout(resolve, ms));\n","  // Returns if a value is really a number\n","  function isNumber(value) {\n","    return typeof value === \"number\" && isFinite(value);\n","  // load RED app server and settings\n","  var app = RED.httpNode;\n","  // var settings = RED.settings;\n","  // configure image static folder\n","  app.use(\"/\", serveStatic(path.join(__dirname, \"images\")));\n","  // node implementation\n","  function CcxtApi(config) {\n","    RED.nodes.createNode(this, config);\n","    //defaults\n","    this.exchange = config.exchange;\n","    this.allexchanges = config.allexchanges || false;\n","    this.apitype = config.apitype;\n","    this.customapitype = config.customapitype;\n","    this.api = config.api;\n","    this.apiprivate = config.apiprivate || false;\n","    this.filtermarkets = config.filtermarkets || \"\";\n","    this.symbol = config.symbol;\n","    this.symbolType = config.symbolType || \"str\";\n","    this.limit = config.limit;\n","    this.limitType = config.limitType || \"num\";\n","    this.since = config.since;\n","    this.sinceType = config.sinceType || \"datepick\";\n","    this.timeframe = config.timeframe;\n","    this.timeframeType = config.timeframeType || \"timeframeList\";\n","    this.ordertype = config.ordertype || \"limit\";\n","    this.orderside = config.orderside || \"buy\";\n","    this.amount = config.amount;\n","    this.orderprice = config.orderprice;\n","    this.orderid = config.orderid;\n","    this.code = config.code;\n","    this.address = config.address;\n","    this.tag = config.tag;\n","    this.apisecrets = RED.nodes.getNode(config.apisecrets);\n","    this.apipayload = config.apipayload;\n","    this.apipayloadType = config.apipayloadType || \"none\";\n","    var node = this;\n","    // if RED httpNodeRoot is not enabled, then ajax calls will not work!\n","    if (RED.settings.httpNodeRoot !== false) {\n","      node.errorHandler = function(err, req, res, next) {\n","        node.warn(err);\n","        res.sendStatus(500);\n","      };\n","      node.callbackExchanges = function(req, res) {\n","        // get my own exchange collection which includes the friendly name of the exchange too\n","        // avoiding to create exchange objects for all exchanges\n","        // get all exchanges\n","        res.setHeader(\"Content-Type\", \"application/json\");\n","        res.send(JSON.stringify({ exchange: exchanges.exchanges }));\n","      node.callbackExchangeCaps = function(req, res) {\n","        //added support to recieve multiple exchange for this call\n","        var rst = req.query.exchange;\n","        //   var exchangeSet = [];\n","        // multi-exchange\n","        // note this is now not needed because every request coming here should ALWAYS\n","        // be an array\n","        // Array.isArray(exchangereq)\n","        //   ? (exchangeSet = exchangereq)\n","        //   : (exchangeSet[0] = exchangereq);\n","        // using ES-6 Set object here for a change !\n","        //let exchangeSet = new Set(exchangereq);\n","        let outputarr = [];\n","        for (let index = 0; index < rst.length; index++) {\n","          const ex = rst[index];\n","          // create the exchange object passing in exchange id\n","          var exchange = new ccxt[ex]();\n","          let arr = [];\n","          if (exchange.has !== undefined) {\n","            arr = Object.entries(exchange.has)\n","              // filter only exchange caps with = true\n","              .filter(function(x) {\n","                // excluding caps that do not represent a unified API (exclude caps named as CORS/privateAPI/publicAPI)\n","                if (x[0] !== \"CORS\" && x[0] !== \"privateAPI\" && x[0] !== \"publicAPI\") {\n","                  // include caps = true and also emulated\n","                  if (x[1] === true || x[1] === \"emulated\") {\n","                    return x;\n","                  }\n","                }\n","              })\n","              .map(function(v) {\n","                //slice out and return only the name\n","                // console.log(\"checking for capability: \", v);\n","                var modarr = v.slice(0, 1);\n","                //lookup if the api is private : return true or false\n","                // then add to the temp array and return the final array\n","                //Note: error will be 'Cannot read property 'filter' of undefined'\n","                // when the capability does not exist on my exchanges unifiedAPI list\n","                modarr.push(\n","                  exchanges.allunfiedAPIs[v[0]].filter(x => x === \"private\").join()\n","                    ? true\n","                    : false\n","                );\n","                return modarr;\n","              });\n","            // if we only have one element just copy array\n","            if (index == 0 && arr.length > 0) outputarr = arr;\n","            if (index > 0 && arr.length > 0) {\n","              // inner join new array with existing array\n","              outputarr = arr.filter(function(c) {\n","                return outputarr.some(ov => ov[0] === c[0]);\n","            }\n","          }\n","        }\n","        // send out the array of all supported unified APIs of the exchange\n","        // including true or false for private apis\n","        res.send(JSON.stringify({ caps: outputarr }));\n","      node.callbackExchangeSymbols = async function(req, res) {\n","        let rst = req.query.exchange;\n","        try {\n","          for (let index = 0; index < rst.length; index++) {\n","            const ex = rst[index];\n","            // instantiate the exchange by id\n","            var exchange = new ccxt[ex]();\n","            let marketsList = [];\n","            // note if fetchMarkets is unsupported then the final list will be empty or filled with other exchange\n","            // markets which support the call. this means that in the rare case that an exchange\n","            // does NOT support the call to fetchMarkets we may get an error message when executing the call to that exchange\n","            // that \"symobol is not supported by the exchange\"\n","            // load all markets from the exchange using fetchMarkets\n","            if (exchange.has[\"fetchMarkets\"]) {\n","              let markets = await exchange.fetchMarkets();\n","              // get all supported symbols from the exchange\n","              marketsList = ccxt\n","                .sortBy(Object.values(markets), \"symbol\")\n","                .map(market => ccxt.omit(market, [\"info\", \"limits\", \"precision\", \"fees\"]))\n","                .map(x => x.symbol);\n","              // if we only have one element just copy array\n","              if (index == 0) outputarr = marketsList;\n","              // if this is a second round we already have an array add to it\n","              if (index > 0 && marketsList.length > 0) {\n","                // inner join new array with incoming array\n","                outputarr = marketsList.filter(function(c) {\n","                  return outputarr.some(ov => ov === c);\n","                });\n","              }\n","            //else loadMarkets ??\n","          res.setHeader(\"Content-Type\", \"application/json\");\n","          res.send(JSON.stringify({ symbols: outputarr }));\n","        } catch (error) {\n","          console.log(error);\n","      node.callbackOHLCVTimeframes = function(req, res) {\n","        let defList = [\"1m\", \"5m\", \"15m\", \"30m\", \"1h\", \"3h\", \"6h\", \"12h\", \"1d\"];\n","        let emulated = false,\n","          unsupported = false,\n","          unsupportedby = \"\";\n","            // note here that if fetchOHLCV is unsupported then the final list will be a default list of timeframes\n","            // for any exchange supplied if fetchOHLCV is supported and yet no values are returned , this means the api is emulated\n","            // a default list will be used for building the final list in this case and emulated will be set to true for the whole payload\n","            // timeframes have default lists that can safely be used in most cases\n","            // even if the exchange api is emulated, we can still use a value from the default list\n","            // create the exchange object\n","            let exchange = new ccxt[ex]();\n","            if (exchange.has[\"fetchOHLCV\"]) {\n","              let tmpList = [];\n","              if (exchange.timeframes) tmpList = Object.keys(exchange.timeframes);\n","              if (tmpList === null || tmpList.length == 0) {\n","                emulated = true;\n","                tmpList = defList;\n","              if (index == 0) outputarr = tmpList;\n","              if (index > 0 && tmpList.length > 0) {\n","                outputarr = tmpList.filter(function(c) {\n","            } else {\n","              //just return empty list response, the api is not supported by one of the exchanges supplied\n","              //but we should possibly return an error here\n","              unsupported = true;\n","              unsupportedby = exchange.name;\n","              //exit the loop if any of the exchnages does not support fetchOHLCV\n","              // this is done to avoid return of partial list\n","              index = rst.length + 1;\n","          res.send(\n","            JSON.stringify({\n","              results: {\n","                fetchOHLCVunsupported: unsupported,\n","                fetchOHLCVunsupportedby: unsupportedby,\n","                fetchOHLCVemulated: emulated,\n","                timeframes: outputarr\n","            })\n","          );\n","      node.callbackApis = function(req, res) {\n","        var exchange = req.query.exchange;\n","        // create the exchange object\n","        exchange = new ccxt[exchange]();\n","        // get exchange.api which includes all custom apis\n","        // provided by the exchange categories into private/public and other groups\n","        res.send(JSON.stringify({ api: exchange.api }));\n","      node.callbackApiParams = function(req, res) {\n","        let api = req.query.api;\n","        let apiparams = getApiParams(api);\n","        res.send(JSON.stringify({ apiparams: apiparams }));\n","      node.corsHandler = function(req, res, next) {\n","        next();\n","    }\n","    // bind get apiMethods\n","    app.get(\"/exchanges\", node.corsHandler, node.callbackExchanges, node.errorHandler);\n","    app.get(\n","      \"/exchangecaps\",\n","      node.corsHandler,\n","      node.callbackExchangeCaps,\n","      node.errorHandler\n","    );\n","    app.get(\"/apis\", node.corsHandler, node.callbackApis, node.errorHandler);\n","    app.get(\"/apiparams\", node.corsHandler, node.callbackApiParams, node.errorHandler);\n","      \"/exchangesymbols\",\n","      node.callbackExchangeSymbols,\n","      \"/fetchOHLCVTimeframes\",\n","      node.callbackOHLCVTimeframes,\n","    // returns parameters of the unified api\n","    // based on the signature of the api in the dictionary\n","    // loaded from our exchanges.js file\n","    function getApiParams(api, extended) {\n","      //TODO: implement extended as true/false\n","      //if true return a required/non-required for each param\n","      let arr = [],\n","        reqparams = [],\n","        optparams = [];\n","      // required parameters appear first and they are string\n","      // exclude the special parameter called private which is just an indicator that\n","      // the api requires credentials\n","      reqparams = exchanges.allunfiedAPIs[api].filter(\n","        x => typeof x === \"string\" && x !== \"private\"\n","      );\n","      // the set of optional parameters are defined as an array\n","      optparams = exchanges.allunfiedAPIs[api].filter(x => typeof x !== \"string\");\n","      //if there are optional params return the names of optional parameters from the array\n","      if (optparams.length > 0) {\n","        optparams = optparams.map(x => x)[0];\n","        //concatenate the required and optional params and close any gaps (closing gaps doesnt really work but it still OK)\n","        arr = reqparams.concat(optparams).filter(function() {\n","          return true;\n","        });\n","        //if we have required params. sometimes we only have optional params\n","      } else if (reqparams.length > 0)\n","        arr = reqparams.filter(function() {\n","      return arr;\n","    // execute ccxt API\n","    node.on(\"input\", function(msg) {\n","      const asyncInput = async function async(config) {\n","        //  let results = [];\n","        //  let res = 0;\n","        let exchangelist = node.exchange;\n","        var api = node.api;\n","        if (node.allexchanges === true)\n","          if (api === \"loadMarkets\") exchangelist = Object.keys(exchanges.exchanges);\n","          else {\n","            node.error(\"All exchanges can only be used with loadMarkets call.\", msg);\n","            return;\n","        for (let index = 0; index < exchangelist.length; index++) {\n","          const element = exchangelist[index];\n","          let addresult = false; // switch is default to false to return the result\n","          // connect to exchange selected\n","          var exchange = undefined;\n","          // obtain secrets if API is private\n","          // applies for both unified and custom(exchange-specific) APIs\n","          //      if Array.isArray(node.exchange) {\n","          try {\n","            //instantiate the exchange\n","            if (node.apiprivate === \"true\") {\n","              if (exchangelist.length > 1)\n","                RED.nodes.eachNode(function(n) {\n","                  // check if n is one you want\n","                  if (n.type === \"ccxt-exchange-v2\")\n","                    if (n.exchange === element)\n","                      if (n.defaultconfig === true) {\n","                        node.apisecrets = RED.nodes.getNode(n.id);\n","                        return;\n","                      }\n","              if (node.apisecrets == undefined) {\n","                node.error(\n","                  \"No Exchange credentials configured for this exchange. If using multiple exchanges for the call, ensure there is one API Keys config is a default.\",\n","                  msg\n","                return;\n","              exchange = new ccxt[element]({\n","                apiKey: node.apisecrets.credentials.apikey,\n","                secret: node.apisecrets.credentials.secret,\n","                uid: node.apisecrets.credentials.uid,\n","                login: node.apisecrets.credentials.login,\n","                password: node.apisecrets.credentials.password\n","            } else exchange = new ccxt[element]();\n","            //enable the built-in rate-limiter\n","            exchange.enableRateLimit = true;\n","            node.status({\n","              fill: \"blue\",\n","              shape: \"dot\",\n","              text: exchange.name + \" : \" + node.api\n","            });\n","            var getVal = function(param) {\n","              // the parameter name should always match the parameter name in the definitions file exchanges.js .\n","              // if no param match undefined would be returned\n","              var value = node[param];\n","              if (value === undefined) return undefined;\n","              // handle parameter by name\n","              if (param === \"apipayload\") {\n","                //here you should handle retrieving the value from all typedinput\n","                //none/json/msg/flow\n","                if (node.apipayloadType === \"none\") value = undefined;\n","                if (node.apipayloadType === \"json\" && value != \"\")\n","                  value = JSON.parse(value);\n","                if (node.apipayloadType === \"msg\")\n","                  value = JSON.stringify(\n","                    RED.util.getMessageProperty(msg, node.apipayload)\n","                  );\n","                if (node.apipayloadType === \"flow\")\n","                    RED.util.evaluateNodeProperty(node.apipayload, value, node, msg)\n","              // special handling for since argument to convert to milliseconds\n","              if (param === \"since\") {\n","                if (node.sinceType === \"msg\") {\n","                  value = RED.util.getMessageProperty(msg, node.since);\n","                if (node.sinceType === \"flow\") {\n","                  value = RED.util.evaluateNodeProperty(node.since, value, node, msg);\n","                // special handling for since parameter\n","                // make sure you get ISO string\n","                // the value can either be a number (long) or a date string.\n","                // if the value is number then i assume its already in milliseconds UTC\n","                // if the value is not a number then i convert the date to milliseconds iso\n","                if (isNumber(value) === false && value !== \"\") {\n","                  value = new Date(value);\n","                  value = exchange.parse8601(value.toISOString());\n","              if (param === \"timeframe\") {\n","                if (node.timeframeType === \"msg\") {\n","                  value = RED.util.getMessageProperty(msg, node.timeframe);\n","                  value = RED.util.evaluateNodeProperty(node.timeframe, value, node, msg);\n","              //market\n","              if (param === \"symbol\") {\n","                if (node.symbolType === \"msg\")\n","                  value = RED.util.getMessageProperty(msg, node.symbol);\n","                if (node.symbolType === \"flow\")\n","                  value = RED.util.evaluateNodeProperty(node.symbol, value, node, msg);\n","                if (node.symbolType === \"allSymbols\") value = exchange.symbols;\n","                // if (node.symbolType === \"symbolList\") value = value.split(\",\");\n","                if (value !== \"\" && !Array.isArray(value)) value = value.split(\",\");\n","              if (value === \"\") value = undefined;\n","              return value;\n","            };\n","            //stream results back to client\n","            let returnResult = async function(resultObj, returnresult) {\n","              if (returnresult === true) {\n","                msg.payload = resultObj;\n","                node.send(msg);\n","            // prepareValue(msg,function(err,msg) {\n","            // if (err) {\n","            //     node.error(err);\n","            //     return;\n","            // }\n","            if (node.apitype === \"unifiedAPI\") {\n","              //3. we need special handling for multi-select of markets (symbols parameter) and using all symbols parameter\n","              if (api === \"loadMarkets\") {\n","                let payload = await exchange.loadMarkets(true);\n","                //filter output of markets if provided\n","                if (node.filtermarkets) {\n","                  // comma separated to array\n","                  let filterlist = node.filtermarkets.split(\",\");\n","                  //filter result here\n","                  payload = Object.keys(payload)\n","                    .filter(key => filterlist.includes(key))\n","                    .reduce((obj, key) => {\n","                      obj[key] = payload[key];\n","                      return obj;\n","                    }, {});\n","                //if we have markets after applying filters then return result showing the exchange and the markets available\n","                if (Object.entries(payload).length > 0) {\n","                  addresult = true;\n","                  returnResult(\n","                    {\n","                      api: api,\n","                      exchange: exchange.name,\n","                      payload: payload\n","                    },\n","                    addresult\n","              } else if (api === \"fetchMarkets\" && exchange.has[\"fetchMarkets\"]) {\n","                let payload = await exchange.fetchMarkets();\n","                  payload = payload.filter(key => {\n","                    return filterlist.includes(key.symbol);\n","                  });\n","                if (payload.length > 0) {\n","              // handling for any Unified API apart from loadMarkets and fetchMarkets is here\n","              // make sure the exchange has the api and execute the api\n","              else if (exchange.has[api]) {\n","                addresult = true;\n","                let marketparm = false;\n","                let marketpos = 0;\n","                let counter = 0;\n","                //this call ensures that exchange has loaded all markets\n","                await exchange.loadMarkets(true);\n","                // return args and check if we have a markets parameter for this unifiedAPI\n","                // TODO : handling for arguments overrides. in some situations exchanges have specific\n","                // requirements for unifiedAPIs most notably some exchanges require api keys for all calls.\n","                let args = getApiParams(api).map(x => {\n","                  if (x === \"symbol\") {\n","                    marketparm = true;\n","                    marketpos = counter;\n","                  counter++;\n","                  return getVal(x);\n","                // call with arguments\n","                if (args.length > 0) {\n","                  //check if market param is used as one of the args\n","                  // this check is needed so that we can also loop over the markets if multiple markets provided\n","                  if (marketparm) {\n","                    // var marketresult;\n","                    let marketsarr = args[marketpos];\n","                    //result = {};\n","                    //[{ market: { symbol: null, result: null } }];\n","                    //  result = {};\n","                    let sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n","                    //empty markets list?\n","                    if (marketsarr) {\n","                      // loop across all markets provided\n","                      for (let index = 0; index < marketsarr.length; index++) {\n","                        const element = marketsarr[index];\n","                        //carefull! modify of array modifies the original.\n","                        // arrays pass by reference in javascript!!\n","                        args[marketpos] = element;\n","                        if (index > 0) await sleep(exchange.rateLimit);\n","                        // add a note about the market being queried for the call\n","                        // useful when there are many markets to use\n","                        node.status({\n","                          fill: \"blue\",\n","                          shape: \"dot\",\n","                          text:\n","                            exchange.name +\n","                            \" : \" +\n","                            node.api +\n","                            \" - \" +\n","                            (marketsarr.length - index).toString() +\n","                            element\n","                        });\n","                        //get the resulting payload then return as streaming msg\n","                        let payload = await exchange[api](...args);\n","                        returnResult(\n","                          {\n","                            api: api,\n","                            exchange: exchange.name,\n","                            arguments: args.concat(),\n","                            market: element,\n","                            payload: payload\n","                          },\n","                          addresult\n","                        );\n","                      // market is a param of the api but no market is provided as an argument\n","                    } else {\n","                      let payload = await exchange[api](...args);\n","                      //console.log(payload);\n","                      returnResult(\n","                        {\n","                          api: api,\n","                          exchange: exchange.name,\n","                          arguments: args.concat(),\n","                          market: \"\",\n","                          payload: payload\n","                        },\n","                        addresult\n","                      );\n","                    }\n","                  } else {\n","                    // market is not a param of this api\n","                    let payload = await exchange[api](...args);\n","                    returnResult(\n","                      {\n","                        api: api,\n","                        exchange: exchange.name,\n","                        arguments: args.concat(),\n","                        payload: payload\n","                      },\n","                      addresult\n","                    );\n","                  // zero args required .. call without any arguments\n","                } else {\n","                  let payload = await exchange[api]();\n","                      arguments: \"\",\n","            } else if (node.apitype === \"customAPI\") {\n","              addresult = true;\n","              //replace special unwanted chars\n","              //this method will form the pattern public_get_method_name which is what ccxt provides for every custom method\n","              let method = api.replace(/\\//g, \"_\").replace(/\\-/g, \"_\");\n","              method = method.replace(/\\{/g, \"\");\n","              method = method.replace(/\\}/g, \"\");\n","              method = node.customapitype + \"_\" + method.toLowerCase();\n","              //invoke api without a payload param\n","              if (node.apipayloadType === \"none\") {\n","                let payload = await exchange[method]();\n","                returnResult(\n","                  {\n","                    api: api,\n","                    exchange: exchange.name,\n","                    arguments: \"\", // iam using the property arguments so it is consistent with the unifiedAPI term. in face this is just the apipayload param\n","                    payload: payload\n","                  },\n","                  addresult\n","              //invoke api with a payload params\n","              else if (node.apipayloadType === \"json\") {\n","                let parsedPayload = JSON.parse(node.apipayload);\n","                let payload = await exchange[method](parsedPayload);\n","                    arguments: parsedPayload,\n","              //todo : handle msg and flow\n","              else if (node.apipayloadType === \"msg\") {\n","                let value = JSON.stringify(\n","                  RED.util.getMessageProperty(msg, node.apipayload)\n","                let parsedPayload = JSON.parse(value);\n","                //custom api with no apipayload param - defaults\n","              } else {\n","                    arguments: \"\",\n","              node.status({\n","                fill: \"yellow\",\n","                shape: \"ring\",\n","                text:\n","                  \"Node Configuration Error. Check that all required parameters for the call are set.\"\n","              node.warning(\"CCXT API configuration error\");\n","            // build api results as an array per exchange\n","            // if (addresult === true) {\n","            //   results = {\n","            //     exchange: exchange.name,\n","            //     api: node.api,\n","            //     //  apitype: node.apitype,\n","            //     payload: result\n","            //   };\n","            //   res++;\n","            //   //stream results\n","            //   msg.payload = results;\n","            //   node.send(msg);\n","            // if (index < node.exchange.length && node.exchange.length > 1) {\n","            //   //sleep 200 milliseconds\n","            //   node.status({ fill: \"blue\", shape: \"dot\", text: \"Zzz..\" });\n","            //   // await sleep(2000);\n","            // clear any node error\n","          } catch (err) {\n","            addresult = node.status({\n","              fill: \"red\",\n","              shape: \"ring\",\n","              text: \"API err: \" + err.message\n","            node.error(err.message, msg);\n","            // return;\n","        // clear any node error\n","        node.status({});\n","        // msg.payload = results;\n","        // node.send(msg);\n","      asyncInput.apply(this, [config]);\n","    });\n","  RED.nodes.registerType(\"ccxt-api-v2\", CcxtApi);\n","  //config node implementation\n","  function CcxtExchange(config) {\n","        res.send(500);\n","      node.callbackExchangerequiredCredentials = function(req, res) {\n","        //TODO: fix bug The Ocean exchange cannot be instantiated\n","        // create the exchange object passing in exchange id\n","        let arr = [];\n","        //(\"requiredCredentials\");\n","        if (exchange.requiredCredentials !== undefined) {\n","          arr = Object.entries(exchange.requiredCredentials)\n","            // return requiredCredentials = true\n","            .filter(function(x) {\n","              if (x[1] === true) {\n","                return x;\n","            .map(function(v) {\n","              //slice out and return only the name\n","              var modarr = v.slice(0, 1);\n","              //lookup if the api is private : return true or false\n","              // then add to the temp array and return the final array\n","              //Note: error will be Cannot read property 'filter' of undefined\n","              // when the capability does not exist onmy list. fix by adding the cap\n","              return modarr;\n","          //each element of the array includes the name of the api\n","          // and whether the api is private\n","        res.send(JSON.stringify({ exchangereqcreds: arr }));\n","      \"/exchangereqcreds\",\n","      node.callbackExchangerequiredCredentials,\n","  RED.nodes.registerType(\"ccxt-exchange-v2\", CcxtExchange, {\n","    credentials: {\n","      apikey: { type: \"text\" },\n","      secret: { type: \"text\" },\n","      uid: { type: \"text\" },\n","      login: { type: \"text\" },\n","      password: { type: \"password\" }\n","  });\n","};\n","//# sourceMappingURL=/ccxt/ccxt-api.js.map\n"],"mappings":"AAAAA;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAF;AACAG;AACAC;AACAC;AACAL;AACAM;AACAC;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAN;;AAEAO;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;;AAEAC;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAN;AACAO;AACAC;AACAC;;AAEAvD;AACAwD;AACAC;AACAC;AACA/D;;AAEAgE;AACAC;AACA9C;;AAEA+C;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAlC;AACAmC;AACAlC;AACAmC;;AAEAC;AACAC;AACAC;AACArC;AACA5D;AACAkG;AACAjC;AACA9C;AACAgF;AACAC;AACAC;AACAC;AACApC;AACAC;AACAC;;AAEAmC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAvB;AACAR;AACAgC;AACA9B;AACA+B;AACA7B;AACA8B;AACA5B;AACAC;AACAC;AACA2B;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACApE;AACAC;;AAEAmC;AACAiC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAzC;AACA0C;AACAC;AACAvC;AACAC;AACArC;AACA5D;AACAwI;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAxI;;AAEAyI;AACA9I;AACA+I;AACAC;;AAEAN;AACAO;AACA5I;;AAEA6I;AACAlJ;AACAmJ;AACAC;AACApJ;AACAqJ;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAP;AACAQ;AACAN;AACAO;AACAL;AACAC;AACAL;AACAU;AACAR;AACAS;AACAP;AACAC;;AAEAO;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAJ;AACAC;;AAEAI;AACA1C;AACA2C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAhJ;;AAEAiJ;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACApI;;AAEAqI;AACAC;AACAC;AACAC;AACAlL;AACAmL;AACAxI;;AAEAyI;AACAC;AACAC;AACAC;AACAC;AACAC;AACAvL;AACAwL;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAH;AACAI;AACAF;AACAtK;AACAyK;AACAC;AACAC;AACAC;AACArO;AACAsO;AACAC;AACAvO;AACAwO;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA/O;AACAyD;AACAuL;AACAC;AACAC;AACAlP;AACAsO;AACAa;AACAnP;AACAyD;AACA2L;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnM;AACAoM;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3M;AACAsM;AACAM;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAxR;AACAyR;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnE;AACA/N;AACAmS;AACAC;AACArB;AACAC;AACAC;AACAC;AACAmB;AACAC;AACAC;AACAvS;AACAwS;AACAb;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnE;AACA/N;AACAyD;AACAgP;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAzT;AACA0T;AACAC;AACAlQ;;AAEAmQ;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAH;AACAI;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3K;AACA4K;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnY;AACAoY;AACAC;AACAC;AACAzG;AACAC;AACAC;AACAC;AACAuG;AACAtG;AACAC;AACAC;AACAnE;AACA/N;AACAyD;AACA8U;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3Y;AACA2C;AACAiW;AACAC;AACAC;AACAC;AACAX;AACAC;AACAC;AACAC;AACAS;AACAP;AACAC;AACAC;AACA3Y;AACA2C;AACAsW;AACAC;AACAC;AACAC;AACApZ;AACAqZ;AACAN;AACAX;AACAC;AACAC;AACAC;AACAS;AACAP;AACAC;AACAC;AACA3Y;;AAEAsZ;AACAC;AACApB;AACAC;AACAC;AACAC;AACAC;AACAiB;AACAf;AACAC;AACAC;AACA3Y;AACA2C;AACA2B;AACAmV;AACAC;AACAC;AACAC;AACAC;AACA3Z;AACA4Z;AACArZ;AACAsZ;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA/K;;AAEAgL;AACAC;AACAC;AACAC;AACAnL;AACAoL;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnP;;AAEAoP;;AAEAC;AACA5a;AACAC;AACA4a;AACAC;AACAC;AACAC;AACA3e;;AAEA4e;AACAC;AACA5hB;;AAEA6hB;;AAEAC;AACAC;AACAlhB;AACA4B;AACAE;AACAC;AACAC;;AAEAmf;AACAjf;;AAEAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAN;;AAEAkf;AACAzW;;AAEA0W;;AAEAC;AACAzW;AACA0W;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAC;AACAC;AACAha;AACA0C;AACAuX;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEAC;AACAlR;AACAmR;AACAC;AACA1c;AACAvD;AACAwD;AACAC;AACAyc;AACAvgB;;AAEAmJ;AACAC;AACApJ;AACAqJ;AACAC;AACAC;AACAC;AACAgX;AACA9W;AACA+W;AACA7W;AACAC;AACA5M;;AAEAyjB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3X;AACA4X;AACAC;AACAC","file":"/ccxt/ccxt-api.js","sourceRoot":"/ccxt/"}